import fs from 'fs/promises';
import path from 'path';
import { ActionType } from '@/types/index.js';

export class OutputManager {
  private outputDir: string;

  constructor(outputDir: string) {
    // Sensible default if empty
    this.outputDir = outputDir && outputDir.trim().length > 0 ? outputDir : 'outputs';
  }

  async ensureDir(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch {
      // ignore
    }
  }

  async ensureOutputDir(): Promise<void> {
    await this.ensureDir(this.outputDir);
  }

  private async resolveOutputPath(
    action: ActionType,
    query: string,
    customPath?: string
  ): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const sanitizedQuery = query
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 50);

    const filename = `${action}-${sanitizedQuery}-${timestamp}.md`;

    if (customPath && customPath.trim().length > 0) {
      const ext = path.extname(customPath);
      // If path exists and is directory, write inside it
      try {
        const stat = await fs.stat(customPath);
        if (stat.isDirectory()) {
          await this.ensureDir(customPath);
          return path.join(customPath, filename);
        }
      } catch {
        // does not exist - decide based on ext
      }

      if (ext) {
        // Treat as file path
        await this.ensureDir(path.dirname(customPath));
        return customPath;
      } else {
        // Treat as directory path
        await this.ensureDir(customPath);
        return path.join(customPath, filename);
      }
    }

    // Fallback to default output directory
    await this.ensureOutputDir();
    return path.join(this.outputDir, filename);
  }

  async saveResponse(
    action: ActionType,
    query: string,
    response: string,
    customPath?: string
  ): Promise<string> {
    const outputPath = await this.resolveOutputPath(action, query, customPath);
    const content = this.formatOutput(action, query, response);
    await fs.writeFile(outputPath, content, 'utf-8');
    return outputPath;
  }

  private formatOutput(action: ActionType, query: string, response: string): string {
    const timestamp = new Date().toISOString();

    return `# ${action.toUpperCase()}: ${query}

**Generated:** ${timestamp}
**Action:** ${action}

---

${response}

---

*Generated by Lean - Learn Anything with AI*
`;
  }

  async saveJsonOutput(
    action: ActionType,
    query: string,
    response: string,
    metadata: Record<string, unknown> = {}
  ): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const sanitizedQuery = query
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 50);

    const filename = `${action}-${sanitizedQuery}-${timestamp}.json`;
    await this.ensureOutputDir();
    const outputPath = path.join(this.outputDir, filename);

    const jsonData = {
      query,
      action,
      response,
      timestamp: new Date().toISOString(),
      metadata,
    };

    await fs.writeFile(outputPath, JSON.stringify(jsonData, null, 2), 'utf-8');

    return outputPath;
  }

  async listOutputs(): Promise<string[]> {
    try {
      const files = await fs.readdir(this.outputDir);
      return files
        .filter((file) => file.endsWith('.md') || file.endsWith('.json'))
        .sort((a, b) => b.localeCompare(a)); // Latest first
    } catch {
      return [];
    }
  }

  async readOutput(filename: string): Promise<string> {
    const filepath = path.join(this.outputDir, filename);
    return await fs.readFile(filepath, 'utf-8');
  }
}
